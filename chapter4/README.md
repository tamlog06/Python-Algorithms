# 帰納と再帰と還元  
## 還元
違う問題を同じアルゴリズムで解こうとする  
基本的にアルゴリズムを学んだ後はこのように、他の知っているアルゴリズムを適用して解くことを考えることになる  

### 例
数字のリストの中から、差の絶対値が最小となる2つの数字を見つけたい
普通に解くと(4-1.py)O(n**2)となってしまう  
しかし、ソートのアルゴリズムを知っていると、ソートはO(nlogn)であり、近いものはソートした後は隣接しているから、結局O(n+nlogn)=O(nlogn)で、計算できる(4-2.py)

## 帰納
問題を小さいサイズに細分して、その解から実際の問題の解を出す  
例は4-2節,解答は(4-3.py)  
小さいサイズから大きいサイズに行くのが帰納

## 再帰
帰納と双対に考えられる  
問題を細分化していく

## 最大置換問題
```8人のバラバラな趣向を持つ人が映画のチケットを買ったとする  
ある者は座席位置に満足するが、大抵の人は不満を持つ  
彼らはお気に入りの席があるので、できるだけ多くの人が満足するように席を交換してもらうとする  
しかし、彼らはそれぞれお気に入りの席にうつれない限りは他の席に移らないと主張している
```
これはマッチング問題の一種であり、図4-4(P95)のようなグラフで表現できる  
この問題を定式化すると、人々の希望が一対一対応、すなわち置換を作っている部分を探すことになる

### 問題の考え方
とにかく、最初のステップは「どこに還元があるのか、どうしたら問題を小さくできるのか、どんな部分問題なら（再帰的に）落とし込むことができるのか、あるいはどんな部分問題なら（帰納的に）既に解けていると仮定できるのか」についてしっかり考え込むことである。  
まず帰納的に解けるか、つまりnからn-1にできるかを考える。  
この時に必要なのは、残った部分問題も同じように解くことができるように１人を減らすこと。  
結局誰も希望していない席を減らしてもいいことが分かる。

### 実装
比較的直感的な実装が(4-4.py)  
指定されている要素Bを作り、それと元の要素Aとの差集合（指定されていない要素）Cを作り、Cの中から一つずつ減らしていく。  
ただこれだと、毎回Bを作る時間が無駄になる。これを解消するには、各要素のカウントを作り、席xを指定していた人が取り除かれた時にそのカウントを減らし、xのカウントが０になった時にその席に座っていた人xと席xをどちらも外せば良い。  
このようにして再帰ではなく反復にしたものが(4-5.py)

## セレブ問題
群衆の中からセレブを見つける問題。考え方は次の通りで、セレブは誰も知らないが、群衆は皆セレブを知っているというもの。同じ問題でより現実的なものは、依存関係の集合を調べて、どれがスタート地点かを調べるというもの。  
これもグラフで書けて、探したいのは他のどのノードからもエッジが入ってきているが、そのノードからは１本もノードが出ていないというもの。

### 問題の考え方
とりあえずブルースフォース的に取り組むのが(4-6.py)  
当然O(n**2)だが、これを線形時間に減らすことは可能。  
前と同様に、問題のサイズを減らして帰納的に解けないかを考える。

## トポロジカルソート
依存関係は有向非巡回グラフ（DAG）として表せる。（全てのエッジが前を指しているような）依存関係を遵守する順序を見つけることをトポロジカルソートと言う。
これはちょっとよく分からなかったので、後でもう一度戻って理解することにする。